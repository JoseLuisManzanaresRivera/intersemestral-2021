---
title: "Tema Distribuciones de probabilidad "
author: "José Luis Manzanares Rivera"
date: 2022-09-02T22:13:14-05:00
categories: ["R"]
tags: ["R Markdown", "plot", "boxplot"]
---

```{r set-global-options, message=FALSE, warning=FALSE,include=FALSE}
knitr::opts_chunk$set(eval = TRUE, 
                      cache = TRUE,
                      include = TRUE,
                      collapse = FALSE,
                      dependson = NULL,
                      engine = "R", # Chunks will always have R code, unless noted
                      error = FALSE)                     

```


```{r silent-packages, echo = FALSE, eval = TRUE, message=FALSE,warning = FALSE}

library(ggplot2)
library(tidyverse)
library(plotly)
```

## Objetivos: 

Estudiar las reglas de probabilidad y las disrtibucións de probabilidad.    

### Meta de aprendizaje: 

Conocer  las  herramientas matemáticas para describir la distribución de datos numéricos en poblaciones y muestras.

#### Contexo:  
Estadística descriptiva.


#### Definiciones.


**Población** Incluye todos los elementos de un conjunto de datos.

**Muestra** Consiste en una o más observaciones de la población.


+ **Parámetro** Característica de una población, tal como la media o la desviación estándar. Frecuentemente se utilizan letras griegas para referirnos a una parámetro.

+ **Estadístico** Una característica medible de una **muestra**. 

**Ejemplos de una estadistico:** 

+ La media de la muestra 
+ El rango de la muestra
+ La desviación de los datos respecto a la media.

![](/img/samples.jpg)


Si no conocemos el **paramétro**  (ingreso medio de los trabajadores en Baja california), podemos estimar el  **estadístico** de una **muestra** y a partir de este **inferir** el parámetro **poblacional** 

La representatividad de la **muestra** es importante  para la validéz del **estadístico** que permite inferir el **parámetro** de interés.


El correcto diseño de nuestros análisis  permite que las **muestras** seleccionadas constituyan una adecuada representación de la **población de estudio**. 


+ **Distribución de muestreo** La distribución de probabiliad de un estadístico dado. Con base en una muestra aleatoria. 

+ **Inferencia estadística** Te permite hacer una conjetura "educada" respecto de un parámetro poblacional, basado en un estadístico calculado usando una muestra aleatoria de la población.


**Convención sobre la notación:** 
Los Parámetros (poblacionales) son denotados generalmente con el uso de letras griegas. Mientras los estadísticos (muestrales) son expresados con letras convencionales.

**Ejemplo.**

Parámetro poblacional $\mu$, Desv std $\sigma$ 
Estadístico muestral $\bar{x}$ Desv std **S**



### Distribuciones de probabilidad.

¿A qué nos referimos cuando hablamos de distribuciones de probabilidad?

A las **herramientas matemáticas** para describir la distribución de datos numéricos en poblaciones y muestras.

## Distribuciones discretas.


Un ejemplo **clásico** simple de una distribución de **probabilidad discreta** es el lanzamiento de un dado. 

Para cada uno de los lados desde $i=1.....6$ la probabilidad de que un lanzamiento del dado tenga la cara $i$ es $$P_{i}=\frac{1}{6}$$  Con $i=1....6$


Las propiedades de la distribución discreta de probabilidad son : 
+ $$0\leq{P_{i}}\leq{1}, 	\forall i \in N$$


+ $$\sum_{i=1}^{n} P_{i}=1$$

#### Ejercicio. 


Genere  un **dado virtual:**

```{r}
1:6
```

Este notación nos permite tener  un lista de números entre 1 y 6, pero es necesario almacenarlos. Para lo cual asignamos un nombre usando el símbolo **$<-** que equivale a decir igual que. 

```{r}
Dado<-1:6
Dado
```

**Note:** Cuando creamos un objeto este aparece en la parte superior derecha en el área de environment.

![](/environment.jpg)




```{r }

## Pruebe generar dados de diferente número de caras.

dado<-1:10
dado


dado<-1:6
dado

dadosietecaras<-1:7
dadosietecaras
```

**¿Qué podemos hacer con el dado?**


Comencemos por algunas operaciones aritméticas.


```{r}

dado-1

dado/2

dado*dado
```

Note que el resultado en cada caso es un vector del mismo tamaño  al vector multiplicado por el  escalar (en este caso 1x6). 

Si multiplicamos un vector (en este caso el vector dado 1x6) cualesquiera, por un vector de un tamaño inferior, R replica los valores del vector de menor tamaño hasta alcanzar el tamaño del primero vector y así permite concretar la operación entre ambos vectores (que son del mismo tamaño). 


Ahora que ya hemos realizado algo de artimética con el dado, veamos cómo podemos lanzarlo para obtener un número aleatorio.

Para este propósito necesitamos una función. 

## Funciones

Para realizar esta tarea de selección de un número aleatorio, necesitamos una función. Construir una función es fácil, únicamente necesitamos el **nombre** y los **argumentos** (entre paréntesis) sobre los cuales se aplicará dicha función. Algunos ejemplos de funciones disponibles de forma automática en R, incluyen:

```{r, echo=TRUE}
round(5.8)

round(3.1416)

factorial(3)
```

Los datos que pasamos en la función los denominamos **argumentos**. Estos pueden ser datos, funciones o resultados de otras funciones. 

**Ejemplo:** 

```{r}
mean(1:6)

mean(dado)

round(mean(dado))
```

Para nuestro propósito de obtener un número aleatorio en un lanzamiento de dado, podemos utilizar la funciòn **sample**, esta toma **dos argumentos**, el vector **x** y el tamaño de la muestra. 


```{r}
sample(x=dado,size=1)

sample(x=1:6,size=1)

```

Es posible omitir la etiqueta del argumetno si recordamos que argumento corresponde con la posición, pero en funciones de mayor tamaño es de ayuda anotar el nombre ya que no siempre recordamos los nombres de todos los argumentos. 

```{r}
sample(dado,1)

sample(1:6,1)
```

Si necesitamos conocer los nombres de los argumentos de alguna función, pasamos el nombre de la función, a la *función* `args()`, Ejemplo  `args(round)` 


```{r}
args(round)
```

**Note** que las funciones incluyen valores predeterminados para algunos argumentos, en el caso anterior el valor del argumento *digits* es 0, de modo que si omitimos este argumento, el resultado será el redondeo al entero próximo, sin decimales. 

```{r}
# Redondeo con dos dígitos 
round(3.1416,2)

# Redondeo con un dígito
round(3.1416,1)

# redondeo con parámetro predeterminado.
round(3.1416)

```

## Muestreo con reemplazo.

Cuando aplicamos la función `sample(dado, size = 2)` notemos que nunca obtenemos dos veces el mismo valor, esto es la función de forma predeterminada considera una muestra aleatoria pero sin reemplazo, para evitar este comportamiento y poder simular el lanzamiento de un dado en realidad en donde podemos obtener por ejemplo el valor 3 y luego otro 3, es necesario inlcuir el argumeto `replace = TRUE`, esto permite que una vez que lanzamos el primer dado, sea posible obtener el mismo valor en el segundo lanzamiento, tal como sucede en el caso real.


```{r}
sample(dado, size = 2, replace = TRUE)
```

El muestreo con reemplazo es una manera fácil de crear muestras aleatorias simples. 

Por ejemplo simular correctamente el lanzamiento de un dado en el que obtenemos **un número aleatorio**  **independiente** cada vez. 


Si deseas sumar el valor del dado para los dos lanzamientos, unicamente aplicamos la función de suma y tenemos el resultado de esta simulación con números aleatorios. 

```{r}
dados <- sample(dado, size = 2, replace = TRUE)
dados

dadosuma<-sum(dados)
dadosuma
```

¿Qué pasaria si indicamos el valor de *dados* varias veces?, cambiará el valor obtenido cada vez que indicamos el nombre del objeto?

```{r}
dados

dados

dados 
```

Vemos que no obtenemos una nueva muestra aleatoria cada vez que indicamos el nombre del objeto, esto es lo que esperamos ya que una vez que aplicamos una función a un conjunto de argumentos y **asignamos un nombre creamos un objeto** y al llamarlo obtenemos el  resultado **permanentemente.**

Si queremos obtener un resultado distinto cada vez que lanzamos el dado podemos especificarlo por medio de una funciòn. 

## Escribe tus propias funciones.

Hasta ahora hemos creado estos objetos:

`dado<-1:6`  

`dados<-sample(dado,2,replace=TRUE)`

`sum(dados)`

pero no sería conveniente que escribiésemos estos objetos cada vez que necesitamos el resultado del lanzamiento 

Para simplificar este proceso podemos construir una **función** que haga el trabajo por nosotros de manera automática.

Hagamos una funciòn llamada `lanzar()`, esta función nos permitirá tener un  valor nuevo  para cada vez que lancemos los dados, sin tener que reescribir cada objeto. 


**las funciones se foman por 3 partes básicas:** un **nombre**, **el cuerpo de código**, y un **conjnto de argumentos**.

Para hacer una función propia, necesitas replicar estos tres componentes y almacenarlos en un **objeto.**.  

Esto lo puedes hacer con la función `function()`. Sólo llama la función   **function()** y síguela con un par de **llaves** {}:

`mi_función <- function() {}`

```{r}
lanzar <- function() {
dado <- 1:6
operacion <- sample(dado, size = 2, replace = TRUE)
sum(operacion)
}

lanzar()
```

## Argumentos

Ahora vamos a incluir  argumentos a nuestra función.
Veamos que sucede cuando incluimos un objeto que no hemos definido, llamémos a este elemento  **tipos**, en lugar del objeto $dado<-1:6$. 

```{r}
lanzar2 <- function() {
dados <- sample(tipos, size = 2, replace = TRUE)
sum(dados)
}
```

`lanzar2()`

Obtenemos un error: **Error: object 'lanzar2' not found**. esto debido a que no existe el objeto **tipos**.

Este comportamiento de hecho nos permite incluir argumentos, para aplicar la función, lo único que necesitamos hacer es indicar este elemento (tipos) como **argumento**. 

Al incluir argumentos en nuestra función, podemos en nuestro ejemplo, especificar diferentes tipos de **dados**. 

Recordemos que estamos haciendo dos lanzamientos con un dato de 6 lados, pero podemos especificar otros tipos de dados, como uno con **20 lados**, uno con 4 o 3,etc. 

Esta información la indicamos mediante los argumentos.

```{r }

lanzar2 <- function(tipo) {
dados <- sample(tipo, size = 2, replace = TRUE)
sum(dados)
}

lanzar2(tipo=1:4)
lanzar2(tipo=1:20)
lanzar2(1:6)
```

`lanzar2(tipo)`

Note que no es necesario nombrar tipo explicitamente, aunque lo podemos hacer para mayor claridad, **esto no es necesario por que  tipo** es el único argumento de nuestra función `lanzar2()`.

Note que la función resulta en un `Error`, cuando no proporcionamos  el argumento tipo  ej. `lanzar2()`. 

Esto es interesante por que de hecho podemos especificar **argumentos predeterminados** al momento de construir la función de tal forma que podemos dejar vacio este espacio cuando estimamos la función. 

```{r}
lanzar2 <- function(tipo=1:6) {
dados <- sample(tipo, size = 2, replace = TRUE)
sum(dados)
}

lanzar2()

lanzar2(1:12)
```

Ahora cuando llamamos la función, obtenemos la información solicitada!

Ahora es posible proporcionar un **tipo** de dado **particular** cada vez que lanzamos el dado, o bien si preferimos dejar el argumento en blanco y la función aplicará el valor predeterminado para el argumento tipo.


En **síntesis** el proceso para crear una función involucra las siguientes partes:

![](/Funciones.jpg)

## Distribuciones de probabilidad.

#### Distribuciones discretas


Dos de las distribuciones discretas más comunes son: la distribución **Binomial** y **Poisson.**

La diferencia básica entre ambas es que la **Binomial** tiene un límite superior definido. 

##### Distribución Binomial. 

Considere la ejecución de una serie de experimentos. 

La distribución binomial aplica si se cumplen los siguientes supuestos: 

+ Los ensayos son independientes. 

+ Cada ensayo tiene la misma probabilidad de exito. 

+ El número de ensayos es conocida 

+ Se define un parámetro denominado **éxitos** "x", como el número de éxitos dentro de los **"n"** ensayos.

De esta forma la función de probabilidad binomial se define como: 

$$P(x)=\frac{n!}{x!(n-x)!}p^{x}(1-p)^{n-x} $$

La función nos permite estimar la probabilidad de que ocurra una cantidad determinada de éxitos.  P(x).  P (mayúscula).

Note que  **p** (mínuscula) es la probabilidad de éxito de cada ensayo y su inverso es la probabilidad de fracaso. 





La **distribución de Bernoulli**

Es una distribución dicotómica. 

Si {\displaystyle X}X es una variable aleatoria discreta que mide el "número de éxitos" y se realiza un único experimento con dos posibles resultados denominados éxito y fracaso, se dice que la variable aleatoria **X** se distribuye como una **Bernoulli** de parámetro **p**  con  $$0<p<1$$ y escribimos   $X\sim \operatorname {Bernoulli} (p)$.

Si  (exito=1 , fracaso =0) , Exito toma la prob. p y fracaso q=(1-p)


![](/img/bernoulli.jpg)


Esta distribución presenta **dos estados.**  Como ejemplo más simple, el lanzamiento de una moneda.
Ver ejemplo **Sesión 3.ipynb**

Otrs ejemplos empíricos con situaciones en donde se presenta una distribución **Binomial**, incluyen todas aquellas situaciones con dos resultados posibles: Ej. Pasar o no el exámen, lanzar una moneda, que un candidato a la presidencia gane o pierda, etc., 


### Distribuciones contínuas.

Muy a menudo, encontramos datos que no se limitan a cifras enteras, por ejemplo el tipo de cambio **Peso/USD**, los registros de temperatura, en estos casos necesitamos una función contínua para describir su distribución.


### KDF Función de densidad Kernel

Permite la representación de la districuión considerando una aproximación contínua,no discreta como es el caso del histograma. 

**Notación:** 
![](/img/kernelDF.jpg)
Donde **K** es una función, usualmente la distribución normal (distribución con  $$\mu=0$$ y $$\sigma=1$$).

En notación esto es: 
$$K(x)=\phi (x)$$ con $\phi$ como la distribución normal.


**h** representa el ancho de clase y toma un valor positivo. $$[0,\infty]$$ Es un parámetro que puede modificarse para generar una distribución con mayor o menor suavidad en la curva. 

Los extremos o limites para **h** son 0, con una curva de densidad sin suavidad e infinito totalmente plana. 

Ejemplo. 

![](/img/kernelnormal.jpg)

**Ejemplo 1** Estimación de funcion de densidad para representar la frecuencia de datos para variables numéricas  y su visualización  por categorias. 
Herramienta de visualización: **ggplotly**.  Funciones aplicadas: **ggplot** **geom_density**.

Contexto de la base de datos. Data frame en formato rds que contiene Edad de  pacientes positivos por covid y edad de defunción en México. Año 2020.

##### Ejemplo 1. 

**Cálculo función de densidad, representación de medidas de tendencia central  y distribución para detectar diferencias de edad.**

```{r, echo= FALSE, fig.height = 5, fig.width = 8.5}

## Source: https://www.gob.mx/salud/documentos/coronavirus-covid-19-comunicado-tecnico-diario-238449

agedf<-readRDS("agedf.rds")


dp<-ggplot(agedf, aes(x=edad, fill=sex))+
geom_density(alpha=.2)+  
labs(color="Sex")+
xlab("Patient age  (years)")+
ylab("Density  f(y)")+
theme_classic()+
scale_fill_discrete(labels=c("Female", "Male"))+
geom_vline(xintercept =mean(agedf$edad), linetype="dotted", color="red")+
annotate("text", x=32, y=.005, size=2,label="Mean patient age")+ theme(legend.title=element_blank())

ggplotly(dp)
```
**Ejemplo 2**  Distribución de edades para defunción por covid en México. 
Funciones estudiadas (Verbos tidyverse aplicados): Filter, select, mutate, summarise. ggplot 

```{r, echo= FALSE}

open<-readRDS("open.rds")

def<-filter(open, resultado==1)%>%
  filter(fecha_def!="9999-99-99")%>%
  select(sexo, edad)
def$sexo[def$sexo == "1"] <- "Female"
def$sexo[def$sexo == "2"] <- "Male"  
def<-mutate(def,sexo=as.factor(sexo))

fmean<-filter(def, sexo=="Female")%>%
  mutate(varmean=mean(edad))%>%
   summarise(mean=mean(varmean))

mmean<-filter(def, sexo=="Male")%>%
  mutate(varmean=mean(edad))%>%
   summarise(varmean=mean(varmean))

  
p<-ggplot(def, aes(x=edad, fill=sexo))+
geom_density(alpha=.2)+  
labs(color="Sex")+
xlab("Person age  (years)")+
ylab("Density  f(y)")+
theme_classic()+
scale_fill_manual(values = c("brown","blue4"))+
geom_vline(xintercept = fmean$mean, linetype="dotted", color="purple")+
geom_vline(xintercept = mmean$varmean, linetype="dotted", color="blue")+
annotate("text", x=44, y=.005, size=3,label="Mean person age")+ theme(legend.title=element_blank())


ggplotly(p)
```


**Ejemplo  3** Función de densidad para dos categorias. 
Funciones estudiadas: group_by, rename, left_join, filter, select, mutate, summarise. ggplot 

####  Caso Aguascalientes


```{r,  fig.height = 8, fig.width = 12,  message=FALSE, warning=FALSE, echo=FALSE}


sdensity<-readRDS("density.rds")%>%
  mutate(s=as.factor(s))%>%
  filter(ENT_RESID!=33& ENT_RESID!=34& ENT_RESID!=35& ENT_RESID!=99)%>%
  group_by(ENT_RESID)

cat_e<-read.csv("cat_entidad.csv")%>%
select(-X)%>%
rename(ent_res=X.U.FEFF.EDO)%>%
mutate(ent_res=sprintf("%02d",ent_res))%>%
mutate(ENT_RESID=as.factor(ent_res))%>%
select(-ent_res)

sdensity<-left_join(sdensity,cat_e)



ags<-filter(sdensity,ENT_RESID=="01")%>%
  mutate(s=as.factor(s))


aplt<-ggplot(ags, aes(x=age,linetype=s, color=s))+
geom_line(stat="density")+
labs(linetype="Causa")+
xlab("Edad de la persona (Años)")+
ylab("Densidad f(y)")+
annotate("segment", x=29, xend=13, y=0.011, yend=0.011,  size=.3, arrow=arrow(length=unit(.2,"cm")))+
annotate("text", x=23, y=0.013, label="Alta incidencia")+
annotate("text", x=21, y=0.009, label="13<Edad<29")+
annotate("rect", xmin=13, xmax=29, ymin=0, ymax=0.03, alpha=.1,fill="black")+
scale_linetype(labels=c("Otras causas","Suicidio"))+
theme_classic()+
scale_color_manual(values = c("mediumturquoise","magenta1"))+
theme(legend.position="none")


aplt

```


**Ejemplo 4** Función de densidad multiples bases de datos. (32 estados de México).
Herramienta de análisis: stat=density 

Funciones estudiadas: **facet_wrap**

```{r,  fig.height = 8, fig.width = 12, message=FALSE, warning=FALSE, echo =FALSE}


mxplt<-ggplot(sdensity, aes(x=age,linetype=s, color=s))+
geom_line(stat="density")+
labs(linetype="Causa")+
xlab("Edad de la persona (Años)")+
ylab("Densidad f(y)")+
facet_wrap(~DESCRIP, nrow=6)+
scale_linetype(labels=c("Otras causas","Suicidio"))+
  theme_classic()+
scale_color_manual(values = c("mediumturquoise","magenta1"))+
  theme(legend.position="none")

mxplt
```



**Nota sobre ventajas de las KDF: **

Nos permiten distinguir rapidamente características como los atributos de tendencia central, la presencia de  bimodalidad,  sesgo), también facilitan la comparación rápida entre diferentes conjuntos de datos.

Por ejemplo vemos en la figura siguiente que la **media** de un conjunto de datos con **sesgo positivo** se ubica **a la derecha** de la mediana.

**IMPORTANTE ** En este caso **la mediana** será la medida de tendencia central **preferible** o que describe con mayor precisión la ubicación del **dato central**, por que divide la distribución de la curva en dos areas iguales. 

![](/img/asimetria_positiva.jpg)

**Una propiedad importante:**

*"El área por debajo de la curva, y entre cualquier intervalo de valores, es la proporción de todas las observaciones que están situadas en dicho intervalo."*

+ Note que el area por debajo de la KDF, siempre es igual a 1. 

En otras palabras, si sumamos la proporción que integra la distribución total, tenemos el 100% 


###  Función de distribución de probabilidad PDF.

La curva que describe la probabilidad para cada valor, (la distribución de probabilidad),  es una **función contínua** y se denomina función de **densidad de probabilidad.** $p(x)=$**(PDF).** 


La **PDF** (función de densidad de una variable **aleatoria continua**), es una función que describe la probabilidad de que una variable aleatoria **X** tome un valor particular **x**  

**X** Variable aleatoria ej. ingreso
**x:** valor particular de la variable aleatoria. ej. $60 000.

La pregunta es ¿cuál es la probabilidad de que la variable **X** tome un valor particular **x**

La **PDF** tiene las propiedades: 


> $${p(x)}\geq0, 	\forall x \in R$$
> $$\int_{-\infty}^{\infty}     p{(x)}dx=1$$

![](/img/PDF_probability.jpg)

La integral de p(x) en el rango [a,b] representa la probabilidad de encontrar el valor **x** en ese **intervalo**.  El area bajo la curva, determina el valor de esa probabilidad en el intervalo particular. A esta area la denominamos función de densidad acumulada **CDF** 



##### Aplicación de la **CDF** a la estimación de los **percentiles.**

La manera más simple de determinar los percentiles es mediante la estimación de la **función de densidad acumulada** **CDF** (por sus siglas en inglés). 
$$CDF(x)=\int_{-\infty}^x PDF(x)dx$$

#### ECDF Función de densidad acumnulativa empírica.

Conocer la frecuencia es importante pero muy a menudo necesitamos conocer que proporción de nuestras observaciones se ubica por debajo de un cierto umbral.

Para este propósito es muy útil estimar la frecuencia acumulada. 

Una representación contínua de este concepto es mediante la función empírica de **densidad  acumulada** 


Una nota sobre la apliación de la **CDF** en la obtención de los **Percentiles** 

Los percentiles permiten determinar el valor por debajo del cual, ocurre un determinado porcentaje de los datos.

La  función de distribución acumulada**CDF** es la integral de la **función de densidad de probabilidad (PDF)**. 

Define la probabilidad de observar un valor **x** en un rango determinado **[a,b].** 
Formalmente 

![](/img/cdf.jpg)


Revisemos ahora en la práctica como podemos estimar la **función de densidad**  usando **Python.**

**"Sesión_2_Tendencia central.ipynb"**

Nota sobre implementación en **Python**. Esta  nos permite observar el porcentaje acumulado de datos en el eje de las ordenadas al orígen y los valores observados en el eje de las absisas.

La pregunta básica que podemos responder estimando la **CDF**, es ¿qué porcentaje de los datos se ubica por debajo de cualquier umbral deseado?
